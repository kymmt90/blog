<!-- 『失敗から学ぶRDBの正しい歩き方』を読んだ -->

2019年の1Qに読んだ本シリーズ:

[asin:4297104083:detail]

RDBのテーブル設計や運用に関するアンチパターンと、それをどうすれば改善できるかについてが解説されています。Software Designの連載がもとになっているので、各章の粒度が多すぎず少なすぎずでちょうどよく読みやすかったです。

内容はWebアプリケーションを作るときに知っておきたいことばかりでした。新しくWebアプリケーション開発の仕事を始めた人に最初にすすめる本としてもちょうどよさそうだと思います。個人的には履歴テーブル、フラグ、隠された状態あたりは最近考えることが多いので、現在どれぐらい実践できているか／できていないかを確認しながら読みました。

また、参考文献が充実しているのもよかったです。[『データベースリファクタリング』](https://www.amazon.co.jp/dp/4894715007)や[『SQLパフォーマンス詳解』](https://www.amazon.co.jp/dp/3950307842)と use-the-index-luke.com 、専門家の人々のスライド資料、MySQLやPostgreSQL公式ドキュメントの該当箇所などなど、より詳細の文献へのポインタが示されており、参考になりました。

## メモ

```markdown
## 第2章 失われた事実

- 税率履歴テーブル
  - 税率、有効日、失効日
  - 注文から参照する
- ステータスは変化するごとにレコードを作り最新を現在とする
- パフォーマンス
  - マテビューかサマリテーブルで対処
- 代替案: レプリ遅延で以前の状態を確認 or ログをESに突っ込む
  - 2番目はonkさんがRailsDMで言ってた

## 第5章 フラグの闇

- 論理削除
  - 未削除と削除済みで同じ値を持つカラムが存在しうるのでユニークにならない
  - フラグのカーディナリティが低い
- 削除済みテーブルに移す or ビュー
- テーブルが肥大化すると後年パフォーマンス面で困るのでわける

## 第6章 ソートの依存

- order byの評価はほぼ最後
  - 一番最後はlimit
- データが大きいほどソートに時間がかかる
- whereで事前に絞る
  - indexを張ったカラム
  - カーディナリティが低い場合は遅い
- order by狙いのindex
  - b-treeのリーフノードはソート済み
  - リーフノードの最初から取り出しながらwhere句を適宜評価すると全部取り出さずに済むので速い
- ページネーションではoffsetよりはページの最初の要素のIDの一個前のID以上、というwhere句のほうが速い

## 第7章 隠された状態

- EAV → JSONで
- Polymorphic Association → 交差テーブルで
- スマートID → 正しく正規化
- 複数目的で使われるテーブル → 分割

## 第8章 JSONの甘い罠

- ユースケース
  - Web APIのレスポンス
  - OS情報
  - ユーザが任意で登録するプラグインの情報

## 第9章 強すぎる制約

- 大切なのはバランス感覚
- 一般的な事実の範囲に収まる制約とする
    - 都道府県が47個、消費税が3以上の整数（消費税が下がるケースは実質無い？）など
  - システムの仕様やビジネスルールに依存しない

## 第14章 ロックの功罪

- 現実のRDBMSはACIDのI (Isolation) を緩めて運用している
  - 厳守しようとするとserializableになる
```
